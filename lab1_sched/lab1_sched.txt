/*
*	DKU Operating System Lab
*	    Lab1 (Scheduler Algorithm Simulator)
*	    Student id : 32170896, 32163395, 32162925
*	    Student name : Kim EunJin, Lee WonJoo, Yun SeulGi
*
*   lab1_sched.c :
*       - Lab1 source file.
*       - Must contain scheduler algorithm function'definition.
*
*/

#include <aio.h>
#include <stdio.h>
#include <stdlib.h>
//#include <fcntl.h> - Why included for 2 times?
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <assert.h>
#include <pthread.h>
#include <asm/unistd.h>

#include "lab1_sched_types.h"

#define TIMESLICE 4
#define QUEUE_NUM 5
/* We defined the TIMESLICE size as 4 !!
 * We defined the # of queues in MLFQ as 5 !! */

/*
 * you need to implement FCFS, RR, SPN, SRT, HRRN, MLFQ scheduler. 
 */

/* Temporary functions for checking purposes */
void print_workload(PROCESS* p_array[], int p_num);
/* Need to be deleted before writting report */

//timer variable for all the functions
int now = 0;
//to manage index of Q's head and tail
int head = -1; //Nothing in Queue
int tail = -1; //Nothing in Queue




int sched_FIFO(PROCESS* p_array[], int p_num)
{
	//First-In-First-Out
	now = 0; //time is always set 0 at first
	//int i; //for loops

//forErrorDetection	
print_workload(p_array, p_num);

	//PROCESS *Queue[p_num]; //Queue for managing processes
	
	//for(i=0; i<p_num; i++) {
	//}
	return 0;
}

int sched_RoundRobin(PROCESS* p_array[], int p_num)
{

printf("\n--------------HERE IS RR----------------\n");
	//Round_Robin
	/* int income is for the index of p_array
	 * if income == 0 again(finished the pushes) and the q is empty,
	 * the now value is turned to -1 and ends the function. */
	int income = 0;
	int detect; //for error detection
	int flag; //for some use...
	int will_add; //value will be added to the "new"
	PROCESS *Queue[p_num]; //Queue for managing processes
	PROCESS *tmpQ = NULL;
	head = -1; //Nothing in Queue
	tail = -1; //Nothing in Queue
	now = 0; //time is always set 0 at first
	//insert_in_Queue(Queue, p_array, p_num);
	
	allocate_memory(Queue, p_num);

/*
	//trying to delete this loop..
	do { //this loop is done till the first push(income == 0).
		if(p_array[income]->t_arrival == now) {
			RRpush(Queue, p_array, NULL, income);
			income = (income+1) % p_num;
		}
		else
			now++;
	}while(!income); //income is 0 again if finishes pushing p_arrs into the Q
*/
	while(now != -1) { //this loop is done till the end of execution
printf("\n--------------time is %d----------------\n", now);
		int i;
		will_add = 0; //value to be added to "now"
		flag = 0;
		detect = 0;

		if(head ^ tail) { //when Queue has any value -> head and tail different
			tmpQ = Queue[head]; //temporary
			detect = RRpop(Queue);
	/*
	 *  other (num > 0) : process is done with pop
	 *  0 : process is !!not!! done with pop
	 * -1 : Empty Queue(head == tail)
	 *
	 * end of pop (means now the Queue will be empty)
	 * 
	 * whatif income==0, now==0?
	*/		
			switch(detect) { //Error detection
				case 0:
					will_add = TIMESLICE;
					break;
				case -1:
					//change of will_add does not happens
					//so, the value of will_add will be 0
					printf("\nError :Empty Queue!!\n");
					break;
				default:
					will_add = detect;
					tmpQ = NULL;
					printf("\n finished RRpop\n");
			}
		}
		//so, if Queue is not empty == any process is executed == will_add will not be 0
		//but will_add will be 0 at the first time..
		//also when func is finished & queue is empty


		for(i=0; ; i++) { //check for any new process during the execution
			while( (income) && (p_array[income]->t_arrival == (now+i)) ) {
				//this is done when income!=0 and p_array[income] is arrived
				detect = RRpush(Queue, p_array, NULL, income);
				switch(detect) { //Error detection
					case -1:
						printf("\nError :Full Queue!!\n");
						break;
					default:
						flag = i;
						printf("\n finished RRpush\n");
				}
				income = (income+1) % p_num;
			} //ends when income==0 or p_array[income]->t_arrival != (now+i)
			
			if( (will_add) && (i == (will_add-1)) ) {
				//case when we have done a pop (will_add != 0)
				//when will_add != 0 but i!= will_add-1, loop will continue.
				break;
			}
			else if( (!will_add) && flag ) {
				//case when will_add == 0 and flag != 0
				//when will_add==0 but flag==0, loop will continue.
				will_add = flag;
				break;
			}
		}

		if(tmpQ != NULL) {
			//if the job was not done, push the job agin into the Queue.
			RRpush(Queue, NULL, tmpQ, -1);
		}

/*
		if(will_add) { //when will_add is not 0 == will_add>0
			for(i=0; i<will_add; i++) { //check for any new process during the execution
				while( (income) && (p_array[income]->t_arrival == (now+i)) ) {
					//this is done when income!=0 and p_array[income] is arrived
					detect = RRpush(Queue, p_array, income);
					switch(detect) { //Error detection
						case -1:
							printf("\nError :Full Queue!!\n");
							break;
						default:
							printf("\n finished RRpush\n");
					}
					income = (income+1) % p_num;
				} //ends when income==0 or p_array[income]->t_arrival != (now+i)
			}
		}
		else { //when will_add is 0
			for(i=0; !will_add; i++) { //check for any new process until???
				while( (income) && (p_array[income]->t_arrival == (now+i)) ) {
					//this is done when income!=0 and p_array[income] is arrived
					detect = RRpush(Queue, p_array, income);
					switch(detect) { //Error detection
						case -1:
							printf("\nError :Full Queue!!\n");
							break;
						default:
							will_add = i;
							printf("\n finished RRpush\n");
					}
					income = (income+1) % p_num;
				} //ends when income==0 or p_array[income]->t_arrival != (now+i)
			}
		}
*/
		if( (!income) && (head == tail)) {
			//nothing for new pushs & Queue empty means the end of the scheduling.
			now = -1; //now breaks the loop!
		}
		else now += will_add;
	}

	return 0;
}

int sched_MLFQ(PROCESS* p_array[], int p_num)
{
	//Muti-Level-Feedback-Queue
	now = 0; //time is always set 0 at first
	return 0;
}

int sched_Lottery(PROCESS* p_array[], int p_num)
{
	//Lottery
	now = 0; //time is always set 0 at first
	return 0;
}

/* Temporary functions for checking purposes */
void print_workload(PROCESS* p_array[], int p_num)
{
	int i;
	for(i=0; i<p_num; i++) {
		printf("\nProcess - %c :\n", p_array[i]->name);
		printf("Arival time : %d \tService time : %d \n", p_array[i]->t_arrival, p_array[i]->t_service);
		printf("Process time : %d \tPriority : %d \n", p_array[i]->t_process, p_array[i]->priority);
	}
	return;
}
/*
void insert_in_Queue(PROCESS* Queue[], PROCESS* p_array[], int p_num)
{
	int i; //for loops
	
	//Initialization process
	for(i=0; i<p_num; i++) {
		Queue[i]->name = p_array[i]->name;
		Queue[i]->t_arrival = p_array[i]->t_arrival;
		Queue[i]->t_service = p_array[i]->t_service;
		Queue[i]->t_process = p_array[i]->t_process;
	}
	return;
}
*/

int RRpop(PROCESS* Queue[])
{
	/*
	 * needed!
	 * pop returns the value that will be added to "now" value after the pop func.
	 * pop returns the integer code for the next works.
	 * 
	 * changes the head and tail value
	 * 
	 * # of elements = tail - head + 1;
	 * if head > tail : tail - head + 6;
	 * 
	 * need make the case of Queue empty!!!!
	 * This IS a ROUGH code!!!
	 *
	 * types of return values:
	 *  other (num > 0) : process is done with pop
	 *  0 : process is !!not!! done with pop
	 * -1 : Empty Queue(head == tail)
	 */

}
int RRpush(PROCESS* Queue[], PROCESS* p_array[], PROCESS* temp, int index)
{
	/*
	 * needed!
	 * returns 0 if succeded
	 *
	 * changes the head and tail value
	 * 
	 * process that came now has the highest priority
	 * so, becomes the head of the queue
	 * 
	 * # of elements = tail - head + 1;
	 * if head > tail : tail - head + 6;
	 *
	 * need make the case of Queue full!!!!
	 * This IS a ROUGH code!!!
	 * 
	 * types of errors:
	 * -1 : Full Queue
	 * -2 : Too few args
	 * -3 : Too many args
	 */
	//static int isValue = 0;
	//for checking the # of values
	int isValue = (head <= tail) ? (tail-head+1) : (tail-head+6);
	int tmp;

	if( (p_array==NULL) && (temp == NULL) ){
		printf("\nError -2 : Too few args.\n");
		return -2;
	}
	else if( (p_array!=NULL) && (temp != NULL) ){
		printf("\nError -3 : Too many args.\n");
		return -3;
	}
	
	if(isValue == 5) {
		printf("\nError -1 : Full Queue\n");
		return -1;
	}
	
	if(p_array != NULL) { //insert New process into Queue
		if(!head) tmp = head-1 +5;
		else tmp = head -1;

		Queue[tmp]->name = p_array[index]->name;
		Queue[tmp]->t_arrival = p_array[index]->t_arrival;
		Queue[tmp]->t_service = p_array[index]->t_service;
		Queue[tmp]->t_process = p_array[index]->t_process;
		isValue++;
	}
	else { //insert Old process back into the Queue
		
	}
}

void allocate_memory(PROCESS* array[], int p_num)
{
	int i; //for loops
	
	//Dinamic allocation of memory
	for(i=0; i<p_num; i++) {
		array[i] = (PROCESS*)malloc(sizeof(PROCESS));
	}
	return;
}

int copy_data(PROCESS* p1, PROCESS* p2)
{
	//copying the data frm p2 to p1
	//need to call with index!!
	//ex. copy_data(Queue[1], p_array[1]);
	
	p1->name = p2->name;
	p1->t_arrival = p2->t_arrival;
	p1->t_service = p2->t_service;
	p1->t_process = p2->t_process;
	p1->priority = p2->priority;
}
